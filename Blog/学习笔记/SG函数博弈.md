# SG函数博弈 #

## 0x00 一些规定 ##
- 游戏必须是对称的且双方都取最优策略
- 规定最后一个进行操作的玩家为负
- A,B：游戏的双方，我们假设A总是刚操作完的一个，即现在轮到B操作，B处于某个状态
- 终止状态：一旦达到这个状态，游戏就无法进行下去
- P状态： 必败状态，如果A接下来的操作没问题，B不可能赢
- N状态： 必胜状态，如果B接下来的操作没问题，A不可能赢

## 0x01 一些很显然的定理 ##
- 所有终止状态都是P状态
- 所有一步能走到P状态的状态都是N状态
- 所有下一步只能走到N状态的状态都是P状态
- 自己想一下就发现很显然了

## 0x02 一个很经典的例子 ##
> NIM游戏
> 有N堆石子，每次操作可以在某一堆里取任意个，双方轮流取，不能取为负

- 把N堆石子的数量异或起来，如果异或和为0，那么先手必败，否则先手必胜
- 为什么？我们考虑两种状态

> 
1. 所有的石子异或和不为0
2. 所有的石子异或和为0


- 显然最后的终止状态属于状态2，即所有堆里都是0
- 如果现在位于状态2，下一步只能走到状态1
- 如果现在位于状态1，下一步一定能走到状态2（请手推一下为什么）
- 那么，状态1就是N状态，2就是P状态，终止状态也是P状态，很对

## 0x03 SG函数 ##
- 如果我们把状态抽象成点，那么整个游戏的状态转移构成一张DAG
- 游戏双方轮流在图上移动，移动到一个没有出度的状态时游戏结束
- 不能移动的玩家输掉游戏
- 因为是DAG，所以游戏总是会结束
- 定义一个状态X，它所有能转移到的状态集合为F(X)
- 定义一种运算mex(Y)，表示Y这个集合在自然数集合中的补集中最小的元素
- 比如Y = {0,2,3,5}，则它的补集是{1,4,6,7....}，mex(Y) = 1
- 定义一个Sprague-Grundy函数（SG函数），其表达式如下
- SG(X) = mex{SG(Z),Z∈F(X)}
- 就是，一个状态所有的转移的SG函数值构成的集合的mex
- 终止状态的SG函数显然为0
- 然后我们发现，我们定义的P状态的SG函数都等于0，N状态的SG函数都大于0
- 回想我们的定义，P状态只能走到N状态（SG函数等于0，表示没有到P状态的转移）
- N状态总能走到P状态（SG函数不为0，有到P状态的转移）
- 并且所有终止状态都是P状态

## 0x04 组合博弈
- 如果一起玩很多组游戏呢
- 一个定理：整个游戏的SG函数就是各个部分的异或和
- 至于怎么证明我不知道

## 0x05 一些例题
- HDU上的NIM系列咯
- 然而可能需要一定的英文水平，不然会看不懂题 
